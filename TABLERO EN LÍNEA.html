<!DOCTYPE html>
<html>
<head>
    <title>Pizarra en Línea con Diapositivas de Imágenes</title>
    <link rel="stylesheet" type="text/css" href="styles.css">

<style>/* Estilo de fondo para el cuerpo de la página */
    body {
        margin: 0;
        padding: 0;
        background-color: #f2f2f2;
        font-family: Arial, sans-serif;
    }
    
    /* Estilo del contenedor de controles */
    .controls {
        background-color: #fff;
        padding: 10px;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    
    /* Estilo de los botones */
    button {
        background-color: #3498db;
        color: #fff;
        border: none;
        padding: 5px 10px;
        margin: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    button:hover {
        background-color: #2980b9;
    }
    
    /* Estilo del lienzo */
    canvas {
        display: block;
        background-color: #fff;
        border: 1px solid #000;
        margin: 0 auto;
        cursor: crosshair;
    }
    
    /* Estilo del rango de tamaño del pincel */
    input[type="range"] {
        width: 20%;
    }
    
    /* Estilo del selector de color */
    input[type="color"] {
        width: 20%;
        padding: 5px;
    }




    
    </style>



</head>
<body>
    <div class="controls">
        <input type="color" id="colorPicker" value="#000000"> <!-- Selector de color -->
    <input type="range" id="brushSizeInput" min="1" max="10" value="5"> <!-- Rango de tamaño del pincel -->
        <input type="file" id="imageInput" accept="image/*" multiple>
        <button id="previousButton">Anterior</button>
        <button id="nextButton">Siguiente</button>
        <button id="clearButton">Limpiar</button>
        <button id="saveButton">Guardar</button>
        <button id="undoButton">Deshacer</button>
        <button id="redoButton">Rehacer</button>


   
    <input type="number" id="timerInput" placeholder="Configurar tiempo (segundos)">
    <button id="startTimerButton">Iniciar Cronómetro</button>
    <button id="resetTimerButton">Reiniciar Cronómetro</button>
    <div id="timerDisplay">Tiempo restante: <span id="timerValue">0</span> segundos</div>


    <audio id="timerSound">
        <source src="sound.mp3" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>
    
        
    </div>
    <canvas id="whiteboard"></canvas>
    <script src="script.js"></script>


<script>

const canvas = document.getElementById('whiteboard');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const imageInput = document.getElementById('imageInput');
const previousButton = document.getElementById('previousButton');
const nextButton = document.getElementById('nextButton');
const clearButton = document.getElementById('clearButton');
const saveButton = document.getElementById('saveButton');
const undoButton = document.getElementById('undoButton');
const redoButton = document.getElementById('redoButton');



canvas.width = 1400; // Ancho del lienzo
canvas.height = 630; // Alto del lienzo

let imageLoaded = false;
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let brushColor = '#000000'; // Color del pincel
let brushSize = 5; // Tamaño del pincel
let drawingHistory = [];
let historyIndex = -1;
let currentImageIndex = -1;
let images = [];
let currentImage = new Image();

// Función para guardar el dibujo como imagen
function saveDrawing() {
    const dataURL = canvas.toDataURL();
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'drawing.png';
    a.click();
}

// Función para cargar una imagen
function loadNewImage(file) {
    if (file) {
        const reader = new FileReader();
        reader.onload = function (event) {
            currentImage.src = event.target.result;
            currentImage.onload = function () {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
                imageLoaded = true;
            };
        };
        reader.readAsDataURL(file);
    }
}

// Función para deshacer el último paso
clearButton.addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingHistory = [];
    historyIndex = -1;
    imageLoaded = false;
    imageInput.value = ''; // Limpiar el input de carga de imagen
    images = []; // Limpiar la lista de imágenes
    currentImageIndex = -1;
});



// Función para deshacer el último paso
undoButton.addEventListener('click', () => {
    if (historyIndex > 0) {
        historyIndex--;
        redraw();
    }
});

// Función para rehacer el último paso
redoButton.addEventListener('click', () => {
    if (historyIndex < drawingHistory.length - 1) {
        historyIndex++;
        redraw();
    }
});












// Manejador de eventos para cargar imágenes
imageInput.addEventListener('change', (e) => {
    images = Array.from(e.target.files);
    currentImageIndex = 0;
    loadNewImage(images[currentImageIndex]);
});

// Función para redibujar el lienzo
function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (imageLoaded) {
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    }

    for (let i = 0; i <= historyIndex; i++) {
        ctx.putImageData(drawingHistory[i], 0, 0);
    }
}

// Función para manejar el dibujo
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mousemove', draw);

function startDrawing(e) {
    isDrawing = true;
    [lastX, lastY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);

    if (historyIndex < drawingHistory.length - 1) {
        drawingHistory = drawingHistory.slice(0, historyIndex + 1);
    }
}

function stopDrawing() {
    isDrawing = false;
    ctx.closePath();

    const drawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    drawingHistory.push(drawingData);
    historyIndex = drawingHistory.length - 1;
}

function draw(e) {
    if (isDrawing) {
        const x = e.clientX - canvas.getBoundingClientRect().left;
        const y = e.clientY - canvas.getBoundingClientRect().top;
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.lineTo(x, y);
        ctx.stroke();
        [lastX, lastY] = [x, y];
    }
}

// Manejadores de eventos para la navegación de imágenes
previousButton.addEventListener('click', () => {
    if (currentImageIndex > 0) {
        currentImageIndex--;
        loadNewImage(images[currentImageIndex]);
    }
});

nextButton.addEventListener('click', () => {
    if (currentImageIndex < images.length - 1) {
        currentImageIndex++;
        loadNewImage(images[currentImageIndex]);
    }
});


// Obtén referencias a los elementos de color y tamaño del pincel
const colorPicker = document.getElementById('colorPicker');
const brushSizeInput = document.getElementById('brushSizeInput');

// Agrega manejadores de eventos para cambios en el color y el tamaño del pincel
colorPicker.addEventListener('input', (e) => {
    brushColor = e.target.value;
    ctx.strokeStyle = brushColor;
});

brushSizeInput.addEventListener('input', (e) => {
    brushSize = e.target.value;
    ctx.lineWidth = brushSize;
});


// Obtén referencias a los elementos relacionados con el cronómetro
const timerInput = document.getElementById('timerInput');
const startTimerButton = document.getElementById('startTimerButton');
const resetTimerButton = document.getElementById('resetTimerButton');
const timerDisplay = document.getElementById('timerDisplay');
const timerValue = document.getElementById('timerValue');

let timerInterval;
let remainingTime = 0;

function updateTimerDisplay() {
    timerValue.textContent = remainingTime;
}


startTimerButton.addEventListener('click', () => {
    const newTime = parseInt(timerInput.value);
    if (!isNaN(newTime) && newTime > 0) {
        clearInterval(timerInterval); // Detener el cronómetro anterior
        remainingTime = newTime;
        updateTimerDisplay();

        // Iniciar el nuevo cronómetro
        timerInterval = setInterval(() => {
            if (remainingTime > 0) {
                remainingTime--;
                updateTimerDisplay();
            } else {
                clearInterval(timerInterval);
            }
        }, 1000);
    }
});

resetTimerButton.addEventListener('click', () => {
    clearInterval(timerInterval);
    remainingTime = 0;
    timerInput.value = ''; // Limpiar el input de configuración
    updateTimerDisplay();
});

// Llamar a updateTimerDisplay inicialmente para mostrar "0 segundos"
updateTimerDisplay();








</script>





</body>
</html>
