<!DOCTYPE html>
<html>
<head>
    <title>Pizarra en Línea con Diapositivas de Imágenes</title>
    <link rel="stylesheet" type="text/css" href="styles.css">

<style>
/* Estilo de fondo para el cuerpo de la página */
    body {
        margin: 0;
        padding: 0;
        background-color: #f2f2f2;
        font-family: Arial, sans-serif;
    }
    
    /* Estilo del contenedor de controles */
    .controls {
        background-color: #fff;
        padding: 10px;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    


button:hover {
    background-color: #2980b9;
}

/* Estilo del botón "Anterior" */
#previousButton {
    background-color: #f39c12;
}

/* Estilo del botón "Siguiente" */
#nextButton {
    background-color: #27ae60;
}

/* Estilo del botón "Limpiar" */
#clearButton {
    background-color: #e74c3c;
}

/* Estilo del botón "Guardar" */
#saveButton {
    background-color: #9b59b6;
}

/* Estilo del botón "Deshacer" */
#undoButton {
    background-color: #3498db;
}

/* Estilo del botón "Rehacer" */
#redoButton {
    background-color: #e74c3c;
}

/* Estilo del botón "Iniciar Cronómetro" */
#startTimerButton {
    background-color: #2ecc71;
}

/* Estilo del botón "Reiniciar Cronómetro" */
#resetTimerButton {
    background-color: #e74c3c;
}

/* Estilo del botón de carga de imagen */
#imageInput {
    background-color: #3498db;
    color: #fff;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 16px;
    border-radius: 5px;
    display: inline-block;
}

/* Estilo del botón de carga de imagen en hover */
#imageInput:hover {
    background-color: #2980b9;
}

/* Estilo de los botones ovalados */
button {
    background-color: #3498db;
    color: #fff;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 16px;
    border-radius: 25px; /* Valor alto para hacer que los botones sean ovalados */
}


#imageInput {
    background-color: #c3f5f5;
    color: #000000; /* Color del texto en blanco */
    border: none;
    padding: 10px 20px;
    margin: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 16px;
    border-radius: 25px; /* Para el botón de carga de imagen */
}


#imageInput:hover {
    background-color: #c7cba7;/* Cambio de color en el hover */
}

/* Estilo del cronómetro */
#timerValue {
    font-weight: bold; /* Texto en negrita */
    font-size: 24px; /* Tamaño de fuente ajustado */
}

   
    /* Estilo del lienzo */
    canvas {
        display: block;
        background-color: #fff;
        border: 1px solid #000;
        margin: 0 auto;
        cursor: crosshair;
    }
    
    /* Estilo del rango de tamaño del pincel */
    input[type="range"] {
        width: 20%;
    }
    
    /* Estilo del selector de color */
    input[type="color"] {
        width: 20%;
        padding: 5px;
    }

    /* Estilo del contenedor de texto */
#textoContenedor {
    background-color: #f9f9f9;
    padding: 10px;
    margin-top: 10px; /* Ajusta la altura del espacio arriba */
    margin-bottom: 10px; /* Ajusta la altura del espacio abajo */
    border: 1px solid #ccc;
    text-align: center;
}



/* Estilo del texto dentro del contenedor */
#textoContenedor p {
    font-size: 18px;
    color: #333;
    font-weight: bold;
}







    </style>



</head>
<body>

   
    

  

    <div class="controls">
        <input type="color" id="colorPicker" value="#000000"> <!-- Selector de color -->
    <input type="range" id="brushSizeInput" min="1" max="10" value="5"> <!-- Rango de tamaño del pincel -->
    <input type="file" id="imageInput" accept="image/*" multiple>
        <button id="previousButton">Anterior</button>
        <button id="nextButton">Siguiente</button><br>
       
        <button id="clearButton">Limpiar</button>
        <button id="undoButton">Deshacer</button>
        <button id="redoButton">Rehacer</button>
        <button id="saveButton">Guardar</button>
        


        
        
    
    
    <input type="number" id="timerInput" placeholder="Configurar tiempo (segundos)">
    <button id="startTimerButton">Iniciar Cronómetro</button>
    <button id="resetTimerButton">Reiniciar Cronómetro</button>
    <STrong><div id="timerDisplay">Tiempo restante: <span id="timerValue">0</span> segundos</div></STrong>


    <audio id="timerSound">
        <source src="sound.mp3" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>
       
    </div>

    <div id="textoContenedor">
        <p>PROGRAMA TRUEQUE AMBIENTAL LOS TUTORES</p>
    </div>
    
    <canvas id="whiteboard"></canvas>
    <script src="script.js"></script>


<script>

const canvas = document.getElementById('whiteboard');
const ctx = canvas.getContext('2d');
const imageInput = document.getElementById('imageInput');
const previousButton = document.getElementById('previousButton');
const nextButton = document.getElementById('nextButton');
const clearButton = document.getElementById('clearButton');
const saveButton = document.getElementById('saveButton');
const undoButton = document.getElementById('undoButton');
const redoButton = document.getElementById('redoButton');
// Obtén referencias a los elementos relacionados con el cronómetro
const timerInput = document.getElementById('timerInput');
const startTimerButton = document.getElementById('startTimerButton');
const resetTimerButton = document.getElementById('resetTimerButton');
const timerDisplay = document.getElementById('timerDisplay');
const timerValue = document.getElementById('timerValue');





canvas.width = 1400; // Ancho del lienzo
canvas.height = 630; // Alto del lienzo

let imageLoaded = false;
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let brushColor = '#000000'; // Color del pincel
let brushSize = 5; // Tamaño del pincel
let drawingHistory = [];
let historyIndex = -1;
let currentImageIndex = -1;
let images = [];
let currentImage = new Image();
let timerInterval; // Variable para el intervalo del cronómetro
let remainingTime = 0; // Tiempo restante en segundos
let soundPlayed = false; // Bandera para controlar si se ha reproducido el sonido


// Función para guardar el dibujo como imagen

saveButton.addEventListener('click', () => {
    saveDrawing();
});


function saveDrawing() {
    console.log("Guardando el dibujo"); // Agregar mensaje de depuración
    const dataURL = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'drawing.png';
    a.click();
}







// Obtén la URL de la imagen dibujada en el lienzo
const dataURL = canvas.toDataURL('image/png');

    








// Función para cargar una imagen
function loadNewImage(file) {
    if (file) {
        const reader = new FileReader();
        reader.onload = function (event) {
            currentImage.src = event.target.result;
            currentImage.onload = function () {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
                imageLoaded = true;
            };
        };
        reader.readAsDataURL(file);
    }
}

// Función para deshacer el último paso
clearButton.addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingHistory = [];
    historyIndex = -1;
    imageLoaded = false;
    imageInput.value = ''; // Limpiar el input de carga de imagen
    images = []; // Limpiar la lista de imágenes
    currentImageIndex = -1;
});



// Función para deshacer el último paso
undoButton.addEventListener('click', () => {
    if (historyIndex > 0) {
        historyIndex--;
        redraw();
    }
});

// Función para rehacer el último paso
redoButton.addEventListener('click', () => {
    if (historyIndex < drawingHistory.length - 1) {
        historyIndex++;
        redraw();
    }
});












// Manejador de eventos para cargar imágenes
imageInput.addEventListener('change', (e) => {
    images = Array.from(e.target.files);
    currentImageIndex = 0;
    loadNewImage(images[currentImageIndex]);
});

// Función para redibujar el lienzo
function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (imageLoaded) {
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    }

    for (let i = 0; i <= historyIndex; i++) {
        ctx.putImageData(drawingHistory[i], 0, 0);
    }
}

// Función para manejar el dibujo
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mousemove', draw);

function startDrawing(e) {
    isDrawing = true;
    [lastX, lastY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);

    if (historyIndex < drawingHistory.length - 1) {
        drawingHistory = drawingHistory.slice(0, historyIndex + 1);
    }
}

function stopDrawing() {
    isDrawing = false;
    ctx.closePath();

    const drawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    drawingHistory.push(drawingData);
    historyIndex = drawingHistory.length - 1;
}

function draw(e) {
    if (isDrawing) {
        const x = e.clientX - canvas.getBoundingClientRect().left;
        const y = e.clientY - canvas.getBoundingClientRect().top;
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.lineTo(x, y);
        ctx.stroke();
        [lastX, lastY] = [x, y];
    }
}

// Manejadores de eventos para la navegación de imágenes
previousButton.addEventListener('click', () => {
    if (currentImageIndex > 0) {
        currentImageIndex--;
        loadNewImage(images[currentImageIndex]);
    }
});

nextButton.addEventListener('click', () => {
    if (currentImageIndex < images.length - 1) {
        currentImageIndex++;
        loadNewImage(images[currentImageIndex]);
    }
});


// Obtén referencias a los elementos de color y tamaño del pincel
const colorPicker = document.getElementById('colorPicker');
const brushSizeInput = document.getElementById('brushSizeInput');

// Agrega manejadores de eventos para cambios en el color y el tamaño del pincel
colorPicker.addEventListener('input', (e) => {
    brushColor = e.target.value;
    ctx.strokeStyle = brushColor;
});

brushSizeInput.addEventListener('input', (e) => {
    brushSize = e.target.value;
    ctx.lineWidth = brushSize;
});





function updateTimerDisplay() {
    timerValue.textContent = remainingTime;
}


startTimerButton.addEventListener('click', () => {
    const newTime = parseInt(timerInput.value);
    if (!isNaN(newTime) && newTime > 0) {
        clearInterval(timerInterval); // Detener el cronómetro anterior
        remainingTime = newTime;
        updateTimerDisplay();
        soundPlayed = false; // Restablecer soundPlayed a false al iniciar el cronómetro


// Iniciar el nuevo cronómetro
timerInterval = setInterval(() => {
            if (remainingTime > 0) {
                remainingTime--;
                updateTimerDisplay();
            } else {
                clearInterval(timerInterval);
            }
        }, 1000);
    }
});

     

resetTimerButton.addEventListener('click', () => {
    clearInterval(timerInterval);
    remainingTime = 0;
    timerInput.value = ''; // Limpiar el input de configuración
    updateTimerDisplay();
});

// Llamar a updateTimerDisplay inicialmente para mostrar "0 segundos"
updateTimerDisplay();



// Función para actualizar la visualización del cronómetro
function updateTimerDisplay() {
    timerValue.textContent = remainingTime;

    if (remainingTime === 0 && !soundPlayed) {
        // Reproducir el sonido cuando el cronómetro llega a cero
        const timerSound = document.getElementById('timerSound');
        timerSound.play();
        soundPlayed = true;
    }

    if (remainingTime < 0) {
        clearInterval(timerInterval);
        timerValue.textContent = '0';
    }
}








</script>





</body>
</html>
